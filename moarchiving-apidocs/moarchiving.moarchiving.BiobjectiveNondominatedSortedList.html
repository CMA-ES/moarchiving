<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>moarchiving.moarchiving.BiobjectiveNondominatedSortedList : API documentation</title>

    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link type="text/css" href="bootstrap.min.css" rel="stylesheet" />
    <link type="text/css" href="apidocs.css" rel="stylesheet" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a href="index.html" class="navbar-brand">
            moarchiving API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button onclick="togglePrivate()" class="btn btn-link">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code>moarchiving.moarchiving.BiobjectiveNondominatedSortedList(<span title="list">list</span>)</code> <small>class documentation</small></h1>

        <span id="partOf">
          Part of <code><a href="moarchiving.html" data-type="Package" class="code">moarchiving</a>.<a href="moarchiving.moarchiving.html" data-type="Module" class="code">moarchiving</a></code>
          
          <a href="classIndex.html#moarchiving.moarchiving.BiobjectiveNondominatedSortedList">(View In Hierarchy)</a>
        </span>
      </div>

      <div class="extrasDocstring">
        
      </div>

      <div class="moduleDocstring">
        <div><p>A sorted list of non-dominated unique objective-pairs.</p>
<p>Non-domination here means smaller in at least one objective. The list is
sorted (naturally) by the first objective. No equal entries in either
objective exist in the list (assuming it is in a consistent state).</p>
<p>The operation</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> moarchiving <span class="py-keyword">import</span> BiobjectiveNondominatedSortedList
<span class="py-prompt">&gt;&gt;&gt; </span>any_list = BiobjectiveNondominatedSortedList(any_list)  <span class="py-comment"># doctest:+SKIP</span></pre>
<p>sorts and prunes the pair list <code>any_list</code> to become a consistent
nondominated sorted archive.</p>
<p>Afterwards, the methods <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#add"><code>add</code></a> and <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#add_list"><code>add_list</code></a> keep the list always
in a consistent state. If a reference point was given on initialization,
also the hypervolume of the archive is computed and updated.</p>
<p>The <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#contributing_hypervolume"><code>contributing_hypervolume</code></a> and <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#hypervolume_improvement"><code>hypervolume_improvement</code></a> methods
give the uncrowded hypervolume improvement, with or without removing
the input from the archive before the computation, respectively, see
<a href="https://arxiv.org/abs/1904.08823" class="rst-reference external" target="_top">https://arxiv.org/abs/1904.08823</a></p>
<p>Removing elements with <code>pop</code> or <code>del</code> keeps the archive sorted and
non-dominated but does not update the hypervolume, which hence
becomes inconsistent.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = BiobjectiveNondominatedSortedList([[1,0.9], [0,1], [0,2]])
<span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">[[0, 1], [1, 0.9]]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a.add([0, 1])  <span class="py-comment"># doesn't change anything, [0, 1] is not duplicated</span>
<span class="py-prompt">&gt;&gt;&gt; </span>BiobjectiveNondominatedSortedList(
<span class="py-more">... </span>    [[-0.749, -1.188], [-0.557, 1.1076],
<span class="py-more">... </span>    [0.2454, 0.4724], [-1.146, -0.110]])
<span class="py-output">[[-1.146, -0.11], [-0.749, -1.188]]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a._asserts()  <span class="py-comment"># consistency assertions</span></pre>
<p>Details: This list doesn't prevent the user to insert a new element
anywhere and hence get into an inconsistent state. Inheriting from
<code>sortedcontainers.SortedList</code> would ensure that the <a href="http://docs.python.org/library/stdtypes.html#list"><code>list</code></a> remains
at least sorted.</p>
<p>See also:
<a href="https://pypi.org/project/sortedcontainers" class="rst-reference external" target="_top">https://pypi.org/project/sortedcontainers</a>
<a href="https://code.activestate.com/recipes/577197-sortedcollection/" class="rst-reference external" target="_top">https://code.activestate.com/recipes/577197-sortedcollection/</a>
<a href="https://pythontips.com/2016/04/24/python-sorted-collections/" class="rst-reference external" target="_top">https://pythontips.com/2016/04/24/python-sorted-collections/</a></p><table class="fieldTable"></table></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id3">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#__init__" data-type="Method" class="code">__init__</a></td>
    <td><span><code>list_of_f_pairs</code> does not need to be sorted.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#add" data-type="Method" class="code">add</a></td>
    <td><span>insert <code>f_pair</code> in <code>self</code> if it is not (weakly) dominated.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#remove" data-type="Method" class="code">remove</a></td>
    <td><span>remove element <code>f_pair</code>.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#add_list" data-type="Method" class="code">add_list</a></td>
    <td><span>insert a list of f-pairs which doesn't need to be sorted.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#merge" data-type="Method" class="code">merge</a></td>
    <td><span>merge in a sorted list of f-pairs.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#copy" data-type="Method" class="code">copy</a></td>
    <td><span>return a "deep" copy of <code>self</code></span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#bisect_left" data-type="Method" class="code">bisect_left</a></td>
    <td><span>return index where <code>f_pair</code> may need to be inserted.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#dominates" data-type="Method" class="code">dominates</a></td>
    <td><span>return <a href="http://docs.python.org/library/constants.html#True"><code>True</code></a> if any element of <code>self</code> dominates or is equal to <code>f_pair</code>.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#dominates_with" data-type="Method" class="code">dominates_with</a></td>
    <td><span>return <a href="http://docs.python.org/library/constants.html#True"><code>True</code></a> if <tt class="rst-docutils literal">self[idx]</tt> dominates or is equal to <code>f_pair</code>.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#dominators" data-type="Method" class="code">dominators</a></td>
    <td><span>return the list of all <code>f_pair</code>-dominating elements in <code>self</code>,</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#in_domain" data-type="Method" class="code">in_domain</a></td>
    <td><span>return <a href="http://docs.python.org/library/constants.html#True"><code>True</code></a> if <code>f_pair</code> is dominating the reference point,</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#hypervolume" data-type="Method" class="code">hypervolume</a></td>
    <td><span>hypervolume of the entire list w.r.t. the "initial" reference point.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#contributing_hypervolumes" data-type="Method" class="code">contributing_hypervolumes</a></td>
    <td><span><a href="http://docs.python.org/library/stdtypes.html#list"><code>list</code></a> of contributing hypervolumes.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#contributing_hypervolume" data-type="Method" class="code">contributing_hypervolume</a></td>
    <td><span>return contributing hypervolume of element <code>idx</code>.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#distance_to_pareto_front" data-type="Method" class="code">distance_to_pareto_front</a></td>
    <td><span>of a dominated <code>f_pair</code> also considering the reference domain.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#distance_to_hypervolume_area" data-type="Method" class="code">distance_to_hypervolume_area</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#hypervolume_improvement" data-type="Method" class="code">hypervolume_improvement</a></td>
    <td><span>return how much <code>f_pair</code> would improve the hypervolume.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#compute_hypervolume" data-type="Method" class="code">compute_hypervolume</a></td>
    <td><span>return hypervolume w.r.t. <code>reference_point</code></span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#compute_hypervolumes" data-type="Method" class="code">compute_hypervolumes</a></td>
    <td><span>depricated, subject to removal, see <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#compute_hypervolume"><code>compute_hypervolume</code></a> and <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#contributing_hypervolumes"><code>contributing_hypervolumes</code></a>.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#prune" data-type="Method" class="code">prune</a></td>
    <td><span>remove dominated or equal entries assuming that the list is sorted.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#discarded" data-type="Method" class="code">discarded</a></td>
    <td><span><a href="http://docs.python.org/library/stdtypes.html#list"><code>list</code></a> of f-pairs discarded in the last relevant method call.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#_add_at" data-type="Method" class="code">_add_at</a></td>
    <td><span>add <code>f_pair</code> at position <code>idx</code> and remove dominated elements.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#_set_HV" data-type="Method" class="code">_set_HV</a></td>
    <td><span>set current hypervolume value using <code>self.reference_point</code>.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#_subtract_HV" data-type="Method" class="code">_subtract_HV</a></td>
    <td><span>remove contributing hypervolumes of elements <tt class="rst-docutils literal">self[idx0] to self[idx1 - 1]</tt>.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#_add_HV" data-type="Method" class="code">_add_HV</a></td>
    <td><span>add contributing hypervolume of <tt class="rst-docutils literal">self[idx]</tt> to hypervolume.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#_state" data-type="Method" class="code">_state</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="staticmethod private">
    
    <td>Static Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#_random_archive" data-type="Static Method" class="code">_random_archive</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#_asserts" data-type="Method" class="code">_asserts</a></td>
    <td><span>make all kind of consistency assertions.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self, list_of_f_pairs=None, reference_point=None, sort=sorted):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p><code>list_of_f_pairs</code> does not need to be sorted.</p>
<p>f-pairs beyond the <code>reference_point</code> are pruned away. The
<code>reference_point</code> is also used to compute the hypervolume.</p>
<p><code>sort</code> is a sorting function and <tt class="rst-docutils literal">sort=None</tt> will prevent a sort,
which can be useful if the <code>list_of_f_pairs</code> is already sorted.</p>
<p>CAVEAT: the interface, in particular the positional interface
may change in future versions.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.add">
    
  </a>
  <a name="add">
    
  </a>
  <div class="functionHeader">
    
    def
    add(self, f_pair):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>insert <code>f_pair</code> in <code>self</code> if it is not (weakly) dominated.</p>
<p>Return index at which the insertion took place or <a href="http://docs.python.org/library/constants.html#None"><code>None</code></a>. The
list remains sorted in the process.</p>
<p>The list remains non-dominated with unique elements, which
means that some or many or even all of its present elements may
be removed.</p>
<p>Implementation detail: For performance reasons, <code>insert</code> is
avoided in favor of <code>__setitem__</code>, if possible.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList._add_at">
    
  </a>
  <a name="_add_at">
    
  </a>
  <div class="functionHeader">
    
    def
    _add_at(self, idx, f_pair):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>add <code>f_pair</code> at position <code>idx</code> and remove dominated elements.</p>
<p>This method assumes that <code>f_pair</code> is not weakly dominated by
<code>self</code> and that <code>idx</code> is the correct insertion place e.g.
acquired by <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#bisect_left"><code>bisect_left</code></a>.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.remove">
    
  </a>
  <a name="remove">
    
  </a>
  <div class="functionHeader">
    
    def
    remove(self, f_pair):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>remove element <code>f_pair</code>.</p>
<p>Raises a <a href="http://docs.python.org/library/exceptions.html#exceptions.ValueError"><code>ValueError</code></a> (like <a href="http://docs.python.org/library/stdtypes.html#list"><code>list</code></a>) if <tt class="rst-docutils literal">f_pair is not in self</tt>.
To avoid the error, checking <tt class="rst-docutils literal">if f_pair is in self</tt> first is a
possible coding solution, like</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> moarchiving <span class="py-keyword">import</span> BiobjectiveNondominatedSortedList
<span class="py-prompt">&gt;&gt;&gt; </span>nda = BiobjectiveNondominatedSortedList([[2, 3]])
<span class="py-prompt">&gt;&gt;&gt; </span>f_pair = [1, 2]
<span class="py-prompt">&gt;&gt;&gt; </span>assert [2, 3] <span class="py-keyword">in</span> nda <span class="py-keyword">and</span> f_pair <span class="py-keyword">not</span> <span class="py-keyword">in</span> nda
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">if</span> f_pair <span class="py-keyword">in</span> nda:
<span class="py-more">... </span>    nda.remove(f_pair)
<span class="py-prompt">&gt;&gt;&gt; </span>nda = BiobjectiveNondominatedSortedList._random_archive(p_ref_point=1)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> t <span class="py-keyword">in</span> [<span class="py-builtin">None</span>, <span class="py-builtin">float</span>]:
<span class="py-more">... </span>    <span class="py-keyword">if</span> t:
<span class="py-more">... </span>        nda.hypervolume_final_float_type = t
<span class="py-more">... </span>        nda.hypervolume_computation_float_type = t
<span class="py-more">... </span>    <span class="py-keyword">for</span> pair <span class="py-keyword">in</span> <span class="py-builtin">list</span>(nda):
<span class="py-more">... </span>        len_ = <span class="py-builtin">len</span>(nda)
<span class="py-more">... </span>        state = nda._state()
<span class="py-more">... </span>        nda.remove(pair)
<span class="py-more">... </span>        assert <span class="py-builtin">len</span>(nda) == len_ - 1
<span class="py-more">... </span>        <span class="py-keyword">if</span> 100 * pair[0] - <span class="py-builtin">int</span>(100 * pair[0]) &lt; 0.7:
<span class="py-more">... </span>            res = nda.add(pair)
<span class="py-more">... </span>            assert <span class="py-builtin">all</span>(state[i] == nda._state()[i] <span class="py-keyword">for</span> i <span class="py-keyword">in</span> (
<span class="py-more">... </span>               [0, 3] <span class="py-keyword">if</span> nda.hypervolume_final_float_type <span class="py-keyword">is</span> <span class="py-builtin">float</span> <span class="py-keyword">else</span> [0, 2, 3]))</pre>
<p>Return <a href="http://docs.python.org/library/constants.html#None"><code>None</code></a> (like <a href="http://docs.python.org/library/stdtypes.html#list.remove"><code>list.remove</code></a>).</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.add_list">
    
  </a>
  <a name="add_list">
    
  </a>
  <div class="functionHeader">
    
    def
    add_list(self, list_of_f_pairs):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>insert a list of f-pairs which doesn't need to be sorted.</p>
<p>This is just a shortcut for looping over <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#add"><code>add</code></a>, but <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#discarded"><code>discarded</code></a>
now contains the discarded elements from all <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#add"><code>add</code></a> operations.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> moarchiving <span class="py-keyword">import</span> BiobjectiveNondominatedSortedList
<span class="py-prompt">&gt;&gt;&gt; </span>arch = BiobjectiveNondominatedSortedList()
<span class="py-prompt">&gt;&gt;&gt; </span>list_of_f_pairs = [[1, 2], [0, 3]]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> f_pair <span class="py-keyword">in</span> list_of_f_pairs:
<span class="py-more">... </span>    arch.add(f_pair)  <span class="py-comment"># return insert index or None</span>
<span class="py-output">0</span>
<span class="py-output">0</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>arch == <span class="py-builtin">sorted</span>(list_of_f_pairs)  <span class="py-comment"># both entries are nondominated</span>
<span class="py-output">True</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>arch.compute_hypervolume([3, 4]) == 5.0
<span class="py-output">True</span></pre>
<p>Return <a href="http://docs.python.org/library/constants.html#None"><code>None</code></a>.</p>
<p>Details: discarded does not contain elements of <code>list_of_f_pairs</code>.
When <code>list_of_pairs</code> is already sorted, <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#merge"><code>merge</code></a> may have
a small performance benefit.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.merge">
    
  </a>
  <a name="merge">
    
  </a>
  <div class="functionHeader">
    
    def
    merge(self, list_of_f_pairs):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>merge in a sorted list of f-pairs.</p>
<p>The list can contain dominated pairs, which are discarded during
the merge.</p>
<p>Return <a href="http://docs.python.org/library/constants.html#None"><code>None</code></a>.</p>
<p>Details: merging 200 into 100_000 takes 3e-4s vs 4e-4s with
<a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#add_list"><code>add_list</code></a>. The <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#discarded"><code>discarded</code></a> property is not consistent with the
overall merge.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.copy">
    
  </a>
  <a name="copy">
    
  </a>
  <div class="functionHeader">
    
    def
    copy(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>return a "deep" copy of <code>self</code><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.bisect_left">
    
  </a>
  <a name="bisect_left">
    
  </a>
  <div class="functionHeader">
    
    def
    bisect_left(self, f_pair, lowest_index=0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>return index where <code>f_pair</code> may need to be inserted.</p>
<p>Smaller indices have a strictly better f1 value or they have
equal f1 and better f2 value.</p>
<p><code>lowest_index</code> restricts the search from below.</p>
<p>Details: This method does a binary search in <code>self</code> using
<a href="http://docs.python.org/library/bisect.html#bisect.bisect_left"><code>bisect.bisect_left</code></a>.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.dominates">
    
  </a>
  <a name="dominates">
    
  </a>
  <div class="functionHeader">
    
    def
    dominates(self, f_pair):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>return <a href="http://docs.python.org/library/constants.html#True"><code>True</code></a> if any element of <code>self</code> dominates or is equal to <code>f_pair</code>.</p>
<p>Otherwise return <a href="http://docs.python.org/library/constants.html#False"><code>False</code></a>.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> moarchiving <span class="py-keyword">import</span> BiobjectiveNondominatedSortedList <span class="py-keyword">as</span> NDA
<span class="py-prompt">&gt;&gt;&gt; </span>a = NDA([[0.39, 0.075], [0.0087, 0.14]])
<span class="py-prompt">&gt;&gt;&gt; </span>a.dominates(a[0])  <span class="py-comment"># is always True if `a` is not empty</span>
<span class="py-output">True</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a.dominates([-1, 33]) <span class="py-keyword">or</span> a.dominates([33, -1])
<span class="py-output">False</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a._asserts()</pre>
<p>See also <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#bisect_left"><code>bisect_left</code></a> to find the closest index.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.dominates_with">
    
  </a>
  <a name="dominates_with">
    
  </a>
  <div class="functionHeader">
    
    def
    dominates_with(self, idx, f_pair):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>return <a href="http://docs.python.org/library/constants.html#True"><code>True</code></a> if <tt class="rst-docutils literal">self[idx]</tt> dominates or is equal to <code>f_pair</code>.</p>
<p>Otherwise return <a href="http://docs.python.org/library/constants.html#False"><code>False</code></a> or <a href="http://docs.python.org/library/constants.html#None"><code>None</code></a> if <code>idx</code> is out-of-range.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> moarchiving <span class="py-keyword">import</span> BiobjectiveNondominatedSortedList <span class="py-keyword">as</span> NDA
<span class="py-prompt">&gt;&gt;&gt; </span>NDA().dominates_with(0, [1, 2]) <span class="py-keyword">is</span> <span class="py-builtin">None</span>  <span class="py-comment"># empty NDA</span>
<span class="py-output">True</span></pre><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.dominators">
    
  </a>
  <a name="dominators">
    
  </a>
  <div class="functionHeader">
    
    def
    dominators(self, f_pair, number_only=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>return the list of all <code>f_pair</code>-dominating elements in <code>self</code>,</p>
<p>including an equal element. <tt class="rst-docutils literal"><span class="pre">len(....dominators(...))</span></tt> is
hence the number of dominating elements which can also be obtained
without creating the list with <tt class="rst-docutils literal">number_only=True</tt>.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> moarchiving <span class="py-keyword">import</span> BiobjectiveNondominatedSortedList <span class="py-keyword">as</span> NDA
<span class="py-prompt">&gt;&gt;&gt; </span>a = NDA([[1.2, 0.1], [0.5, 1]])
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">len</span>(a)
<span class="py-output">2</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a.dominators([2, 3]) == a
<span class="py-output">True</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a.dominators([0.5, 1])
<span class="py-output">[[0.5, 1]]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">len</span>(a.dominators([0.6, 3])), a.dominators([0.6, 3], number_only=<span class="py-builtin">True</span>)
<span class="py-output">(1, 1)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a.dominators([0.5, 0.9])
<span class="py-output">[]</span></pre><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.in_domain">
    
  </a>
  <a name="in_domain">
    
  </a>
  <div class="functionHeader">
    
    def
    in_domain(self, f_pair, reference_point=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>return <a href="http://docs.python.org/library/constants.html#True"><code>True</code></a> if <code>f_pair</code> is dominating the reference point,</p>
<p><a href="http://docs.python.org/library/constants.html#False"><code>False</code></a> otherwise. <a href="http://docs.python.org/library/constants.html#True"><code>True</code></a> means that <code>f_pair</code> contributes to
the hypervolume if not dominated by other elements.</p>
<p><code>f_pair</code> may also be an index in <code>self</code> in which case
<tt class="rst-docutils literal">self[f_pair]</tt> is tested to be in-domain.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> moarchiving <span class="py-keyword">import</span> BiobjectiveNondominatedSortedList <span class="py-keyword">as</span> NDA
<span class="py-prompt">&gt;&gt;&gt; </span>a = NDA([[2.2, 0.1], [0.5, 1]], reference_point=[2, 2])
<span class="py-prompt">&gt;&gt;&gt; </span>assert <span class="py-builtin">len</span>(a) == 1
<span class="py-prompt">&gt;&gt;&gt; </span>a.in_domain([0, 0])
<span class="py-output">True</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a.in_domain([2, 1])
<span class="py-output">False</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">all</span>(a.in_domain(ai) <span class="py-keyword">for</span> ai <span class="py-keyword">in</span> a)
<span class="py-output">True</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a.in_domain(0)
<span class="py-output">True</span></pre>
<p>TODO: improve name?</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.hypervolume">
    
  </a>
  <a name="hypervolume">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    hypervolume(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>hypervolume of the entire list w.r.t. the "initial" reference point.</p>
<p>Raise <a href="http://docs.python.org/library/exceptions.html#exceptions.ValueError"><code>ValueError</code></a> when no reference point was given initially.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> moarchiving <span class="py-keyword">import</span> BiobjectiveNondominatedSortedList <span class="py-keyword">as</span> NDA
<span class="py-prompt">&gt;&gt;&gt; </span>a = NDA([[0.5, 0.4], [0.3, 0.7]], [2, 2.1])
<span class="py-prompt">&gt;&gt;&gt; </span>a._asserts()
<span class="py-prompt">&gt;&gt;&gt; </span>a.reference_point == [2, 2.1]
<span class="py-output">True</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">abs</span>(a.hypervolume - a.compute_hypervolume(a.reference_point)) &lt; 1e-11
<span class="py-output">True</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a.add([0.2, 0.8])
<span class="py-output">0</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a._asserts()
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">abs</span>(a.hypervolume - a.compute_hypervolume(a.reference_point)) &lt; 1e-11
<span class="py-output">True</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a.add([0.3, 0.6])
<span class="py-output">1</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a._asserts()
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">abs</span>(a.hypervolume - a.compute_hypervolume(a.reference_point)) &lt; 1e-11
<span class="py-output">True</span></pre><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.contributing_hypervolumes">
    
  </a>
  <a name="contributing_hypervolumes">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    contributing_hypervolumes(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p><a href="http://docs.python.org/library/stdtypes.html#list"><code>list</code></a> of contributing hypervolumes.</p>
<p>Elements in the list are of type
<code>self.hypervolume_computation_float_type</code>.
Conversion to <a href="http://docs.python.org/library/stdtypes.html#float"><code>float</code></a> in a list comprehension should always be
possible.</p>
<p>Changing this list will have unexpected consequences if
<code>self.maintain_contributing_hypervolumes</code>,</p>
<p>Details: The "initial" reference point is used for the outer
points. If none is given, <code>inf</code> is used as reference.
For the time being, the contributing hypervolumes are
computed each time from scratch.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#contributing_hypervolume"><code>contributing_hypervolume</code></a></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.contributing_hypervolume">
    
  </a>
  <a name="contributing_hypervolume">
    
  </a>
  <div class="functionHeader">
    
    def
    contributing_hypervolume(self, idx):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>return contributing hypervolume of element <code>idx</code>.</p>
<p>If <code>idx</code> is an <code>f_pair</code>, return contributing hypervolume of element
with value <code>f_pair</code>. If <code>f_pair</code> is not in <code>self</code>, return
<code>hypervolume_improvement(f_pair)</code>.</p>
<p>The return type is <tt class="rst-docutils literal">self.hypervolume_computation_float_type` and
by default `fractions.Fraction`, which can be converted to `float`
like <span class="pre">``float(....contributing_hypervolume(idx))</span></tt>.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.distance_to_pareto_front">
    
  </a>
  <a name="distance_to_pareto_front">
    
  </a>
  <div class="functionHeader">
    
    def
    distance_to_pareto_front(self, f_pair, ref_factor=1):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>of a dominated <code>f_pair</code> also considering the reference domain.</p>
<p>Non-dominated points have (by definition) a distance of zero,
unless the archive is empty and the point does not dominate the
reference point.</p>
<p>Assumes that extreme points in the archive are in the reference
domain.</p>
<p>Details: the distance for dominated points is computed by
iterating over the relevant kink points <tt class="rst-docutils literal"><span class="pre">(self[i+1][0],</span>
<span class="pre">self[i][1])</span></tt>. In case of minimization, the boundary with two
non-dominated points can be depicted like:</p>
<pre class="rst-literal-block">
...______.      . &lt;- reference point
         |
         x__. &lt;- kink point
            |
            x___. &lt;- kink point
                |
                |
                :
                :
</pre>
<p>The three kink points which are possibly used for the computations
are denoted by a dot. The outer kink points use one coordinate of
the reference point.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.distance_to_hypervolume_area">
    
  </a>
  <a name="distance_to_hypervolume_area">
    
  </a>
  <div class="functionHeader">
    
    def
    distance_to_hypervolume_area(self, f_pair):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.hypervolume_improvement">
    
  </a>
  <a name="hypervolume_improvement">
    
  </a>
  <div class="functionHeader">
    
    def
    hypervolume_improvement(self, f_pair):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>return how much <code>f_pair</code> would improve the hypervolume.</p>
<p>If dominated, return the distance to the empirical pareto front
multiplied by -1.
Else if not in domain, return distance to the reference point
dominating area times -1.</p>
<p>Overall this amounts to the uncrowded hypervolume improvement,
see <a href="https://arxiv.org/abs/1904.08823" class="rst-reference external" target="_top">https://arxiv.org/abs/1904.08823</a></p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList._set_HV">
    
  </a>
  <a name="_set_HV">
    
  </a>
  <div class="functionHeader">
    
    def
    _set_HV(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>set current hypervolume value using <code>self.reference_point</code>.</p>
<p>Raise <a href="http://docs.python.org/library/exceptions.html#exceptions.ValueError"><code>ValueError</code></a> if <code>self.reference_point</code> is <a href="http://docs.python.org/library/constants.html#None"><code>None</code></a>.</p>
<p>TODO: we may need to store the list of _contributing_ hypervolumes
to handle numerical rounding errors later.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.compute_hypervolume">
    
  </a>
  <a name="compute_hypervolume">
    
  </a>
  <div class="functionHeader">
    
    def
    compute_hypervolume(self, reference_point):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>return hypervolume w.r.t. <code>reference_point</code><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.compute_hypervolumes">
    
  </a>
  <a name="compute_hypervolumes">
    
  </a>
  <div class="functionHeader">
    
    def
    compute_hypervolumes(self, reference_point):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>depricated, subject to removal, see <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#compute_hypervolume"><code>compute_hypervolume</code></a> and <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#contributing_hypervolumes"><code>contributing_hypervolumes</code></a>.</p>
<p>Never implemented: return list of contributing hypervolumes w.r.t.
reference_point</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList._subtract_HV">
    
  </a>
  <a name="_subtract_HV">
    
  </a>
  <div class="functionHeader">
    
    def
    _subtract_HV(self, idx0, idx1=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>remove contributing hypervolumes of elements <tt class="rst-docutils literal">self[idx0] to self[idx1 - 1]</tt>.</p>
<p>TODO: also update list of contributing hypervolumes in case.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList._add_HV">
    
  </a>
  <a name="_add_HV">
    
  </a>
  <div class="functionHeader">
    
    def
    _add_HV(self, idx):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>add contributing hypervolume of <tt class="rst-docutils literal">self[idx]</tt> to hypervolume.</p>
<p>TODO: also update list of contributing hypervolumes in case.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.prune">
    
  </a>
  <a name="prune">
    
  </a>
  <div class="functionHeader">
    
    def
    prune(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>remove dominated or equal entries assuming that the list is sorted.</p>
<p>Return number of dropped elements.</p>
<p>Implementation details: pruning from right to left may be
preferable, because list.insert(0) is O(n) while list.append is
O(1), however it is not possible with the given sorting: in
principle, the first element may dominate all others, which can
only be discovered in the last step when traversing from right
to left. This suggests that reverse sort may be better for
pruning or we should inherit from <a href="http://docs.python.org/library/collections.html#collections.deque"><code>collections.deque</code></a> instead
from <a href="http://docs.python.org/library/stdtypes.html#list"><code>list</code></a>, but <code>deque</code> seems not to support deletion of slices.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.discarded">
    
  </a>
  <a name="discarded">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    discarded(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p><a href="http://docs.python.org/library/stdtypes.html#list"><code>list</code></a> of f-pairs discarded in the last relevant method call.</p>
<p>Methods covered are <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#__init__"><code>__init__</code></a>, <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#prune"><code>prune</code></a>, <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#add"><code>add</code></a>, and <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#add_list"><code>add_list</code></a>.
Removed duplicates are not element of the discarded list.
When not inserted and not already in <code>self</code> also the input
argument(s) show(s) up in <a href="moarchiving.moarchiving.BiobjectiveNondominatedSortedList.html#discarded"><code>discarded</code></a>.</p>
<p>Example to create a list of rank-k-non-dominated fronts:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> moarchiving <span class="py-keyword">import</span> BiobjectiveNondominatedSortedList <span class="py-keyword">as</span> NDA
<span class="py-prompt">&gt;&gt;&gt; </span>all_ = [[0.1, 1], [-2, 3], [-4, 5], [-4, 5], [-4, 4.9]]
<span class="py-prompt">&gt;&gt;&gt; </span>nda_list = [NDA(all_)]  <span class="py-comment"># rank-0-non-dominated</span>
<span class="py-prompt">&gt;&gt;&gt; </span>while nda_list[-1].discarded:
<span class="py-more">... </span>    nda_list += [NDA(nda_list[-1].discarded)]
<span class="py-prompt">&gt;&gt;&gt; </span>assert [<span class="py-builtin">len</span>(p) <span class="py-keyword">for</span> p <span class="py-keyword">in</span> nda_list] == [3, 1]</pre><table class="fieldTable"></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList._state">
    
  </a>
  <a name="_state">
    
  </a>
  <div class="functionHeader">
    
    def
    _state(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basestaticmethod private">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList._random_archive">
    
  </a>
  <a name="_random_archive">
    
  </a>
  <div class="functionHeader">
    @staticmethod<br />
    def
    _random_archive(max_size=500, p_ref_point=0.5):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod private">
  
  <a name="moarchiving.moarchiving.BiobjectiveNondominatedSortedList._asserts">
    
  </a>
  <a name="_asserts">
    
  </a>
  <div class="functionHeader">
    
    def
    _asserts(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>make all kind of consistency assertions.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> moarchiving
<span class="py-prompt">&gt;&gt;&gt; </span>a = moarchiving.BiobjectiveNondominatedSortedList(
<span class="py-more">... </span>   [[-0.749, -1.188], [-0.557, 1.1076],
<span class="py-more">... </span>   [0.2454, 0.4724], [-1.146, -0.110]], [10, 10])
<span class="py-prompt">&gt;&gt;&gt; </span>a._asserts()
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> i <span class="py-keyword">in</span> <span class="py-builtin">range</span>(<span class="py-builtin">len</span>(a)):
<span class="py-more">... </span>   assert a.contributing_hypervolume(i) == a.contributing_hypervolumes[i]
<span class="py-prompt">&gt;&gt;&gt; </span>assert <span class="py-builtin">all</span>(<span class="py-builtin">map</span>(<span class="py-keyword">lambda</span> x, y: x - 1e-9 &lt; y &lt; x + 1e-9,
<span class="py-more">... </span>              a.contributing_hypervolumes,
<span class="py-more">... </span>              [4.01367, 11.587422]))
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> p <span class="py-keyword">in</span> <span class="py-builtin">list</span>(a):
<span class="py-more">... </span>    a.remove(p)
<span class="py-prompt">&gt;&gt;&gt; </span>assert <span class="py-builtin">len</span>(a) == 0
<span class="py-prompt">&gt;&gt;&gt; </span>try: a.remove([0, 0])
<span class="py-more">... </span><span class="py-keyword">except</span> <span class="py-builtin">ValueError</span>: <span class="py-keyword">pass</span>
<span class="py-more">... </span><span class="py-keyword">else</span>: raise <span class="py-builtin">AssertionError</span>(<span class="py-string">"remove did not raise ValueError"</span>)</pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> numpy.random <span class="py-keyword">import</span> rand
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> _ <span class="py-keyword">in</span> <span class="py-builtin">range</span>(120):
<span class="py-more">... </span>    a = moarchiving.BiobjectiveNondominatedSortedList._random_archive()
<span class="py-more">... </span>    a.make_expensive_asserts = <span class="py-builtin">True</span>
<span class="py-more">... </span>    <span class="py-keyword">if</span> a.reference_point:
<span class="py-more">... </span>        <span class="py-keyword">for</span> f_pair <span class="py-keyword">in</span> rand(10, 2):
<span class="py-more">... </span>            h0 = a.hypervolume
<span class="py-more">... </span>            hi = a.hypervolume_improvement(<span class="py-builtin">list</span>(f_pair))
<span class="py-more">... </span>            assert a.hypervolume == h0  <span class="py-comment"># works OK with Fraction</span></pre><table class="fieldTable"></table></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for moarchiving, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> at 2020-06-01 23:58:25.
      </address>

    </div>

    <script type="text/javascript" src="pydoctor.js"></script>

  </body>
</html>